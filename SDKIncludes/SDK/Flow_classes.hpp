#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Flow

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "Flow_structs.hpp"
#include "MovieSceneTracks_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"
#include "LevelSequence_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class Flow.FlowOwnerInterface
// 0x0000 (0x0000 - 0x0000)
class IFlowOwnerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowOwnerInterface">();
	}
	static class IFlowOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFlowOwnerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFlowOwnerInterface) == 0x000001, "Wrong alignment on IFlowOwnerInterface");
static_assert(sizeof(IFlowOwnerInterface) == 0x000001, "Wrong size on IFlowOwnerInterface");

// Class Flow.FlowSaveGame
// 0x0030 (0x0058 - 0x0028)
class UFlowSaveGame final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFlowComponentSaveData>         FlowComponents;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FFlowAssetSaveData>             FlowInstances;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSaveGame">();
	}
	static class UFlowSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowSaveGame>();
	}
};
static_assert(alignof(UFlowSaveGame) == 0x000008, "Wrong alignment on UFlowSaveGame");
static_assert(sizeof(UFlowSaveGame) == 0x000058, "Wrong size on UFlowSaveGame");
static_assert(offsetof(UFlowSaveGame, SaveSlotName) == 0x000028, "Member 'UFlowSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UFlowSaveGame, FlowComponents) == 0x000038, "Member 'UFlowSaveGame::FlowComponents' has a wrong offset!");
static_assert(offsetof(UFlowSaveGame, FlowInstances) == 0x000048, "Member 'UFlowSaveGame::FlowInstances' has a wrong offset!");

// Class Flow.FlowAsset
// 0x01F8 (0x0220 - 0x0028)
class UFlowAsset : public UObject
{
public:
	struct FGuid                                  AssetGuid;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldBound;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x4F];                                      // 0x0039(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class UFlowNode*>          Nodes;                                             // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UFlowAsset*>                     ActiveInstances;                                   // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFlowAsset*                             TemplateAsset;                                     // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x60];                                      // 0x00F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UFlowNode_CustomInput*>            CustomInputNodes;                                  // 0x0150(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<class UFlowNode*>                        PreloadedNodes;                                    // 0x01A0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class UFlowNode*>                      ActiveNodes;                                       // 0x01F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UFlowNode*>                      RecordedNodes;                                     // 0x0200(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UObject>                    ExpectedOwnerClass;                                // 0x0218(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class UFlowNode*> GetNodesInExecutionOrder(class UFlowNode* FirstIteratedNode, const TSubclassOf<class UFlowNode> FlowNodeClass);
	bool IsBoundToWorld();
	void LoadInstance(const struct FFlowAssetSaveData& AssetRecord);
	void OnLoad();
	void OnSave();
	struct FFlowAssetSaveData SaveInstance(TArray<struct FFlowAssetSaveData>* SavedFlowInstances);

	const TArray<class UFlowNode*> GetActiveNodes() const;
	class UFlowNode* GetDefaultEntryNode() const;
	class UObject* GetOwner() const;
	const TArray<class UFlowNode*> GetRecordedNodes() const;
	bool IsActive() const;
	class AActor* TryFindActorOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAsset">();
	}
	static class UFlowAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAsset>();
	}
};
static_assert(alignof(UFlowAsset) == 0x000008, "Wrong alignment on UFlowAsset");
static_assert(sizeof(UFlowAsset) == 0x000220, "Wrong size on UFlowAsset");
static_assert(offsetof(UFlowAsset, AssetGuid) == 0x000028, "Member 'UFlowAsset::AssetGuid' has a wrong offset!");
static_assert(offsetof(UFlowAsset, bWorldBound) == 0x000038, "Member 'UFlowAsset::bWorldBound' has a wrong offset!");
static_assert(offsetof(UFlowAsset, Nodes) == 0x000088, "Member 'UFlowAsset::Nodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, ActiveInstances) == 0x0000D8, "Member 'UFlowAsset::ActiveInstances' has a wrong offset!");
static_assert(offsetof(UFlowAsset, TemplateAsset) == 0x0000E8, "Member 'UFlowAsset::TemplateAsset' has a wrong offset!");
static_assert(offsetof(UFlowAsset, CustomInputNodes) == 0x000150, "Member 'UFlowAsset::CustomInputNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, PreloadedNodes) == 0x0001A0, "Member 'UFlowAsset::PreloadedNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, ActiveNodes) == 0x0001F0, "Member 'UFlowAsset::ActiveNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, RecordedNodes) == 0x000200, "Member 'UFlowAsset::RecordedNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, ExpectedOwnerClass) == 0x000218, "Member 'UFlowAsset::ExpectedOwnerClass' has a wrong offset!");

// Class Flow.FlowComponent
// 0x0120 (0x01C0 - 0x00A0)
class UFlowComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IdentityTags;                                      // 0x00A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AddedIdentityTags;                                 // 0x00C8(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  RemovedIdentityTags;                               // 0x00E8(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UFlowComponent* FlowComponent, const struct FGameplayTagContainer& CurrentTags)> OnIdentityTagsAdded; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFlowComponent* FlowComponent, const struct FGameplayTagContainer& CurrentTags)> OnIdentityTagsRemoved; // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RecentlySentNotifyTags;                            // 0x0128(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  NotifyTagsFromGraph;                               // 0x0160(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UFlowComponent* FlowComponent, const struct FGameplayTag& NotifyTag)> ReceiveNotify; // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FNotifyTagReplication>          NotifyTagsFromAnotherComponent;                    // 0x0190(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	class UFlowAsset*                             RootFlow;                                          // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStartRootFlow;                                // 0x01A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlowNetMode                                  RootFlowMode;                                      // 0x01A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleInstances;                           // 0x01AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AB[0x5];                                      // 0x01AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedAssetInstanceName;                            // 0x01B0(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddIdentityTag(const struct FGameplayTag& Tag, const EFlowNetMode NetMode);
	void AddIdentityTags(const struct FGameplayTagContainer& Tags, const EFlowNetMode NetMode);
	void BP_OnTriggerRootFlowOutputEvent(class UFlowAsset* RootFlowInstance, const class FName& EventName);
	void BulkNotifyGraph(const struct FGameplayTagContainer& NotifyTags, const EFlowNetMode NetMode);
	void FinishRootFlow(class UFlowAsset* TemplateAsset, const EFlowFinishPolicy FinishPolicy);
	bool LoadInstance();
	void LoadRootFlow();
	void NotifyActor(const struct FGameplayTag& ActorTag, const struct FGameplayTag& NotifyTag, const EFlowNetMode NetMode);
	void NotifyGraph(const struct FGameplayTag& NotifyTag, const EFlowNetMode NetMode);
	void OnLoad();
	void OnRep_AddedIdentityTags();
	void OnRep_NotifyTagsFromAnotherComponent();
	void OnRep_NotifyTagsFromGraph();
	void OnRep_RemovedIdentityTags();
	void OnRep_SentNotifyTags();
	void OnSave();
	void RemoveIdentityTag(const struct FGameplayTag& Tag, const EFlowNetMode NetMode);
	void RemoveIdentityTags(const struct FGameplayTagContainer& Tags, const EFlowNetMode NetMode);
	struct FFlowComponentSaveData SaveInstance();
	void SaveRootFlow(TArray<struct FFlowAssetSaveData>* SavedFlowInstances);
	void StartRootFlow();

	class UFlowAsset* GetRootFlowInstance() const;
	TSet<class UFlowAsset*> GetRootInstances(const class UObject* Owner) const;
	void LogError(const class FString& Message, const EFlowOnScreenMessageType OnScreenMessageType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowComponent">();
	}
	static class UFlowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowComponent>();
	}
};
static_assert(alignof(UFlowComponent) == 0x000008, "Wrong alignment on UFlowComponent");
static_assert(sizeof(UFlowComponent) == 0x0001C0, "Wrong size on UFlowComponent");
static_assert(offsetof(UFlowComponent, IdentityTags) == 0x0000A8, "Member 'UFlowComponent::IdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, AddedIdentityTags) == 0x0000C8, "Member 'UFlowComponent::AddedIdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RemovedIdentityTags) == 0x0000E8, "Member 'UFlowComponent::RemovedIdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, OnIdentityTagsAdded) == 0x000108, "Member 'UFlowComponent::OnIdentityTagsAdded' has a wrong offset!");
static_assert(offsetof(UFlowComponent, OnIdentityTagsRemoved) == 0x000118, "Member 'UFlowComponent::OnIdentityTagsRemoved' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RecentlySentNotifyTags) == 0x000128, "Member 'UFlowComponent::RecentlySentNotifyTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, NotifyTagsFromGraph) == 0x000160, "Member 'UFlowComponent::NotifyTagsFromGraph' has a wrong offset!");
static_assert(offsetof(UFlowComponent, ReceiveNotify) == 0x000180, "Member 'UFlowComponent::ReceiveNotify' has a wrong offset!");
static_assert(offsetof(UFlowComponent, NotifyTagsFromAnotherComponent) == 0x000190, "Member 'UFlowComponent::NotifyTagsFromAnotherComponent' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RootFlow) == 0x0001A0, "Member 'UFlowComponent::RootFlow' has a wrong offset!");
static_assert(offsetof(UFlowComponent, bAutoStartRootFlow) == 0x0001A8, "Member 'UFlowComponent::bAutoStartRootFlow' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RootFlowMode) == 0x0001A9, "Member 'UFlowComponent::RootFlowMode' has a wrong offset!");
static_assert(offsetof(UFlowComponent, bAllowMultipleInstances) == 0x0001AA, "Member 'UFlowComponent::bAllowMultipleInstances' has a wrong offset!");
static_assert(offsetof(UFlowComponent, SavedAssetInstanceName) == 0x0001B0, "Member 'UFlowComponent::SavedAssetInstanceName' has a wrong offset!");

// Class Flow.FlowOwnerFunctionParams
// 0x0010 (0x0038 - 0x0028)
class UFlowOwnerFunctionParams final : public UObject
{
public:
	class UFlowNode_CallOwnerFunction*            SourceNode;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExecutedInputPinName;                              // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BP_PostExecute();
	void BP_PreExecute();

	TArray<class FName> BP_GetInputNames() const;
	TArray<class FName> BP_GetOutputNames() const;
	bool ShouldFinishForOutputName(const class FName& OutputName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowOwnerFunctionParams">();
	}
	static class UFlowOwnerFunctionParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowOwnerFunctionParams>();
	}
};
static_assert(alignof(UFlowOwnerFunctionParams) == 0x000008, "Wrong alignment on UFlowOwnerFunctionParams");
static_assert(sizeof(UFlowOwnerFunctionParams) == 0x000038, "Wrong size on UFlowOwnerFunctionParams");
static_assert(offsetof(UFlowOwnerFunctionParams, SourceNode) == 0x000028, "Member 'UFlowOwnerFunctionParams::SourceNode' has a wrong offset!");
static_assert(offsetof(UFlowOwnerFunctionParams, ExecutedInputPinName) == 0x000030, "Member 'UFlowOwnerFunctionParams::ExecutedInputPinName' has a wrong offset!");

// Class Flow.FlowSettings
// 0x0028 (0x0060 - 0x0038)
class UFlowSettings final : public UDeveloperSettings
{
public:
	bool                                          bCreateFlowSubsystemOnClients;                     // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnAboutMissingIdentityTags;                     // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogOnSignalDisabled;                              // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogOnSignalPassthrough;                           // 0x003B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdaptiveNodeTitles;                            // 0x003C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         DefaultExpectedOwnerClass;                         // 0x0040(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSettings">();
	}
	static class UFlowSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowSettings>();
	}
};
static_assert(alignof(UFlowSettings) == 0x000008, "Wrong alignment on UFlowSettings");
static_assert(sizeof(UFlowSettings) == 0x000060, "Wrong size on UFlowSettings");
static_assert(offsetof(UFlowSettings, bCreateFlowSubsystemOnClients) == 0x000038, "Member 'UFlowSettings::bCreateFlowSubsystemOnClients' has a wrong offset!");
static_assert(offsetof(UFlowSettings, bWarnAboutMissingIdentityTags) == 0x000039, "Member 'UFlowSettings::bWarnAboutMissingIdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowSettings, bLogOnSignalDisabled) == 0x00003A, "Member 'UFlowSettings::bLogOnSignalDisabled' has a wrong offset!");
static_assert(offsetof(UFlowSettings, bLogOnSignalPassthrough) == 0x00003B, "Member 'UFlowSettings::bLogOnSignalPassthrough' has a wrong offset!");
static_assert(offsetof(UFlowSettings, bUseAdaptiveNodeTitles) == 0x00003C, "Member 'UFlowSettings::bUseAdaptiveNodeTitles' has a wrong offset!");
static_assert(offsetof(UFlowSettings, DefaultExpectedOwnerClass) == 0x000040, "Member 'UFlowSettings::DefaultExpectedOwnerClass' has a wrong offset!");

// Class Flow.FlowSubsystem
// 0x0158 (0x0188 - 0x0030)
class UFlowSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UFlowAsset*>                     InstancedTemplates;                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class UFlowAsset*, TWeakObjectPtr<class UObject>> RootInstances;                            // 0x0040(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class UFlowNode_SubGraph*, class UFlowAsset*> InstancedSubFlows;                            // 0x0090(0x0050)(NativeAccessSpecifierPrivate)
	class UFlowSaveGame*                          LoadedSaveGame;                                    // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnSaveGame;                                        // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x50];                                      // 0x00F8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UFlowComponent* Component)> OnComponentRegistered;           // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFlowComponent* Component, const struct FGameplayTagContainer& Tags)> OnComponentTagAdded; // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFlowComponent* Component)> OnComponentUnregistered;         // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UFlowComponent* Component, const struct FGameplayTagContainer& Tags)> OnComponentTagRemoved; // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AbortActiveFlows();
	void FinishAllRootFlows(class UObject* Owner, const EFlowFinishPolicy FinishPolicy);
	void FinishRootFlow(class UObject* Owner, class UFlowAsset* TemplateAsset, const EFlowFinishPolicy FinishPolicy);
	void LoadRootFlow(class UObject* Owner, class UFlowAsset* FlowAsset, const class FString& SavedAssetInstanceName);
	void LoadSubFlow(class UFlowNode_SubGraph* SubGraphNode, const class FString& SavedAssetInstanceName);
	void OnGameLoaded(class UFlowSaveGame* SaveGame);
	void OnGameSaved(class UFlowSaveGame* SaveGame);
	void StartRootFlow(class UObject* Owner, class UFlowAsset* FlowAsset, const bool bAllowMultipleInstances);

	TMap<class AActor*, class UFlowComponent*> GetFlowActorsAndComponentsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class AActor> actorClass, const bool bExactMatch) const;
	TMap<class AActor*, class UFlowComponent*> GetFlowActorsAndComponentsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class AActor> actorClass, const bool bExactMatch) const;
	TSet<class AActor*> GetFlowActorsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class AActor> actorClass, const bool bExactMatch) const;
	TSet<class AActor*> GetFlowActorsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class AActor> actorClass, const bool bExactMatch) const;
	TSet<class UFlowComponent*> GetFlowComponentsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class UFlowComponent> ComponentClass, const bool bExactMatch) const;
	TSet<class UFlowComponent*> GetFlowComponentsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class UFlowComponent> ComponentClass, const bool bExactMatch) const;
	const TMap<class UFlowNode_SubGraph*, class UFlowAsset*> GetInstancedSubFlows() const;
	class UFlowSaveGame* GetLoadedSaveGame() const;
	class UFlowAsset* GetRootFlow(const class UObject* Owner) const;
	TMap<class UObject*, class UFlowAsset*> GetRootInstances() const;
	TSet<class UFlowAsset*> GetRootInstancesByOwner(const class UObject* Owner) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSubsystem">();
	}
	static class UFlowSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowSubsystem>();
	}
};
static_assert(alignof(UFlowSubsystem) == 0x000008, "Wrong alignment on UFlowSubsystem");
static_assert(sizeof(UFlowSubsystem) == 0x000188, "Wrong size on UFlowSubsystem");
static_assert(offsetof(UFlowSubsystem, InstancedTemplates) == 0x000030, "Member 'UFlowSubsystem::InstancedTemplates' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, RootInstances) == 0x000040, "Member 'UFlowSubsystem::RootInstances' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, InstancedSubFlows) == 0x000090, "Member 'UFlowSubsystem::InstancedSubFlows' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, LoadedSaveGame) == 0x0000E0, "Member 'UFlowSubsystem::LoadedSaveGame' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnSaveGame) == 0x0000E8, "Member 'UFlowSubsystem::OnSaveGame' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentRegistered) == 0x000148, "Member 'UFlowSubsystem::OnComponentRegistered' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentTagAdded) == 0x000158, "Member 'UFlowSubsystem::OnComponentTagAdded' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentUnregistered) == 0x000168, "Member 'UFlowSubsystem::OnComponentUnregistered' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentTagRemoved) == 0x000178, "Member 'UFlowSubsystem::OnComponentTagRemoved' has a wrong offset!");

// Class Flow.FlowWorldSettings
// 0x0008 (0x04C0 - 0x04B8)
class AFlowWorldSettings final : public AWorldSettings
{
public:
	class UFlowComponent*                         FlowComponent;                                     // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowWorldSettings">();
	}
	static class AFlowWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowWorldSettings>();
	}
};
static_assert(alignof(AFlowWorldSettings) == 0x000008, "Wrong alignment on AFlowWorldSettings");
static_assert(sizeof(AFlowWorldSettings) == 0x0004C0, "Wrong size on AFlowWorldSettings");
static_assert(offsetof(AFlowWorldSettings, FlowComponent) == 0x0004B8, "Member 'AFlowWorldSettings::FlowComponent' has a wrong offset!");

// Class Flow.FlowLevelSequenceActor
// 0x0008 (0x0310 - 0x0308)
class AFlowLevelSequenceActor final : public ALevelSequenceActor
{
public:
	class ULevelSequence*                         ReplicatedLevelSequenceAsset;                      // 0x0308(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_ReplicatedLevelSequenceAsset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLevelSequenceActor">();
	}
	static class AFlowLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowLevelSequenceActor>();
	}
};
static_assert(alignof(AFlowLevelSequenceActor) == 0x000008, "Wrong alignment on AFlowLevelSequenceActor");
static_assert(sizeof(AFlowLevelSequenceActor) == 0x000310, "Wrong size on AFlowLevelSequenceActor");
static_assert(offsetof(AFlowLevelSequenceActor, ReplicatedLevelSequenceAsset) == 0x000308, "Member 'AFlowLevelSequenceActor::ReplicatedLevelSequenceAsset' has a wrong offset!");

// Class Flow.FlowLevelSequencePlayer
// 0x0008 (0x05C0 - 0x05B8)
class UFlowLevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	class UFlowNode*                              FlowEventReceiver;                                 // 0x05B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLevelSequencePlayer">();
	}
	static class UFlowLevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowLevelSequencePlayer>();
	}
};
static_assert(alignof(UFlowLevelSequencePlayer) == 0x000008, "Wrong alignment on UFlowLevelSequencePlayer");
static_assert(sizeof(UFlowLevelSequencePlayer) == 0x0005C0, "Wrong size on UFlowLevelSequencePlayer");
static_assert(offsetof(UFlowLevelSequencePlayer, FlowEventReceiver) == 0x0005B8, "Member 'UFlowLevelSequencePlayer::FlowEventReceiver' has a wrong offset!");

// Class Flow.MovieSceneFlowSectionBase
// 0x0000 (0x00F0 - 0x00F0)
class UMovieSceneFlowSectionBase : public UMovieSceneSection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowSectionBase">();
	}
	static class UMovieSceneFlowSectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowSectionBase>();
	}
};
static_assert(alignof(UMovieSceneFlowSectionBase) == 0x000008, "Wrong alignment on UMovieSceneFlowSectionBase");
static_assert(sizeof(UMovieSceneFlowSectionBase) == 0x0000F0, "Wrong size on UMovieSceneFlowSectionBase");

// Class Flow.MovieSceneFlowRepeaterSection
// 0x0010 (0x0100 - 0x00F0)
class UMovieSceneFlowRepeaterSection final : public UMovieSceneFlowSectionBase
{
public:
	class FString                                 EventName;                                         // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowRepeaterSection">();
	}
	static class UMovieSceneFlowRepeaterSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowRepeaterSection>();
	}
};
static_assert(alignof(UMovieSceneFlowRepeaterSection) == 0x000008, "Wrong alignment on UMovieSceneFlowRepeaterSection");
static_assert(sizeof(UMovieSceneFlowRepeaterSection) == 0x000100, "Wrong size on UMovieSceneFlowRepeaterSection");
static_assert(offsetof(UMovieSceneFlowRepeaterSection, EventName) == 0x0000F0, "Member 'UMovieSceneFlowRepeaterSection::EventName' has a wrong offset!");

// Class Flow.MovieSceneFlowTrack
// 0x0020 (0x00B8 - 0x0098)
class UMovieSceneFlowTrack final : public UMovieSceneNameableTrack
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFireEventsAtPosition                         EventPosition;                                     // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowTrack">();
	}
	static class UMovieSceneFlowTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowTrack>();
	}
};
static_assert(alignof(UMovieSceneFlowTrack) == 0x000008, "Wrong alignment on UMovieSceneFlowTrack");
static_assert(sizeof(UMovieSceneFlowTrack) == 0x0000B8, "Wrong size on UMovieSceneFlowTrack");
static_assert(offsetof(UMovieSceneFlowTrack, EventPosition) == 0x0000A4, "Member 'UMovieSceneFlowTrack::EventPosition' has a wrong offset!");
static_assert(offsetof(UMovieSceneFlowTrack, Sections) == 0x0000A8, "Member 'UMovieSceneFlowTrack::Sections' has a wrong offset!");

// Class Flow.MovieSceneFlowTriggerSection
// 0x0110 (0x0200 - 0x00F0)
class UMovieSceneFlowTriggerSection final : public UMovieSceneFlowSectionBase
{
public:
	struct FMovieSceneStringChannel               StringChannel;                                     // 0x00F0(0x0110)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowTriggerSection">();
	}
	static class UMovieSceneFlowTriggerSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowTriggerSection>();
	}
};
static_assert(alignof(UMovieSceneFlowTriggerSection) == 0x000008, "Wrong alignment on UMovieSceneFlowTriggerSection");
static_assert(sizeof(UMovieSceneFlowTriggerSection) == 0x000200, "Wrong size on UMovieSceneFlowTriggerSection");
static_assert(offsetof(UMovieSceneFlowTriggerSection, StringChannel) == 0x0000F0, "Member 'UMovieSceneFlowTriggerSection::StringChannel' has a wrong offset!");

// Class Flow.FlowNode
// 0x00B0 (0x00D8 - 0x0028)
class UFlowNode : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEdGraphNode*                           GraphNode;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  NodeGuid;                                          // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EFlowSignalMode>                       AllowedSignalModes;                                // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EFlowSignalMode                               SignalMode;                                        // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFlowPin>                       InputPins;                                         // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFlowPin>                       OutputPins;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FConnectedPin>       Connections;                                       // 0x0080(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x1];                                       // 0x00D0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EFlowNodeState                                ActivationState;                                   // 0x00D1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString GetClassDescription(const TSubclassOf<class UObject> Class_0);
	static class FString GetIdentityTagDescription(const struct FGameplayTag& Tag);
	static class FString GetIdentityTagsDescription(const struct FGameplayTagContainer& Tags);
	static class FString GetNotifyTagsDescription(const struct FGameplayTagContainer& Tags);
	static class FString GetProgressAsString(float Value);

	void Finish();
	void K2_Cleanup();
	void K2_DeinitializeInstance();
	void K2_ExecuteInput(const class FName& PinName);
	void K2_FlushContent();
	void K2_ForceFinishNode();
	class AActor* K2_GetActorToFocus();
	class FString K2_GetAssetPath();
	class UObject* K2_GetAssetToEdit();
	void K2_InitializeInstance();
	void K2_OnActivate();
	void K2_PreloadContent();
	void LoadInstance(const struct FFlowNodeSaveData& NodeRecord);
	void LogError(const class FString& Message, const EFlowOnScreenMessageType OnScreenMessageType);
	void LogNote(const class FString& Message);
	void LogWarning(const class FString& Message);
	void OnLoad();
	void OnPassThrough();
	void OnSave();
	void SaveInstance(struct FFlowNodeSaveData* NodeRecord);
	void SetGuid(const struct FGuid& NewGuid);
	void TriggerFirstOutput(const bool bFinish);
	void TriggerOutput(const class FName& PinName, const bool bFinish, const EFlowPinActivationType ActivationType);
	void TriggerOutputPin(const struct FFlowOutputPinHandle& Pin, const bool bFinish, const EFlowPinActivationType ActivationType);

	TSet<class UFlowNode*> GetConnectedNodes() const;
	class UFlowAsset* GetFlowAsset() const;
	class UFlowSubsystem* GetFlowSubsystem() const;
	const struct FGuid GetGuid() const;
	TArray<class FName> GetInputNames() const;
	TArray<class FName> GetOutputNames() const;
	bool IsInputConnected(const class FName& PinName) const;
	bool IsOutputConnected(const class FName& PinName) const;
	bool K2_CanUserAddInput() const;
	bool K2_CanUserAddOutput() const;
	class FString K2_GetNodeDescription() const;
	bool K2_GetStatusBackgroundColor(struct FLinearColor* OutColor) const;
	class FString K2_GetStatusString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode">();
	}
	static class UFlowNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode>();
	}
};
static_assert(alignof(UFlowNode) == 0x000008, "Wrong alignment on UFlowNode");
static_assert(sizeof(UFlowNode) == 0x0000D8, "Wrong size on UFlowNode");
static_assert(offsetof(UFlowNode, GraphNode) == 0x000030, "Member 'UFlowNode::GraphNode' has a wrong offset!");
static_assert(offsetof(UFlowNode, NodeGuid) == 0x000038, "Member 'UFlowNode::NodeGuid' has a wrong offset!");
static_assert(offsetof(UFlowNode, AllowedSignalModes) == 0x000048, "Member 'UFlowNode::AllowedSignalModes' has a wrong offset!");
static_assert(offsetof(UFlowNode, SignalMode) == 0x000058, "Member 'UFlowNode::SignalMode' has a wrong offset!");
static_assert(offsetof(UFlowNode, InputPins) == 0x000060, "Member 'UFlowNode::InputPins' has a wrong offset!");
static_assert(offsetof(UFlowNode, OutputPins) == 0x000070, "Member 'UFlowNode::OutputPins' has a wrong offset!");
static_assert(offsetof(UFlowNode, Connections) == 0x000080, "Member 'UFlowNode::Connections' has a wrong offset!");
static_assert(offsetof(UFlowNode, ActivationState) == 0x0000D1, "Member 'UFlowNode::ActivationState' has a wrong offset!");

// Class Flow.FlowNodeBlueprint
// 0x0000 (0x00A8 - 0x00A8)
class UFlowNodeBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNodeBlueprint">();
	}
	static class UFlowNodeBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNodeBlueprint>();
	}
};
static_assert(alignof(UFlowNodeBlueprint) == 0x000008, "Wrong alignment on UFlowNodeBlueprint");
static_assert(sizeof(UFlowNodeBlueprint) == 0x0000A8, "Wrong size on UFlowNodeBlueprint");

// Class Flow.FlowNode_LogicalAND
// 0x0050 (0x0128 - 0x00D8)
class UFlowNode_LogicalAND final : public UFlowNode
{
public:
	TSet<class FName>                             ExecutedInputNames;                                // 0x00D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_LogicalAND">();
	}
	static class UFlowNode_LogicalAND* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_LogicalAND>();
	}
};
static_assert(alignof(UFlowNode_LogicalAND) == 0x000008, "Wrong alignment on UFlowNode_LogicalAND");
static_assert(sizeof(UFlowNode_LogicalAND) == 0x000128, "Wrong size on UFlowNode_LogicalAND");
static_assert(offsetof(UFlowNode_LogicalAND, ExecutedInputNames) == 0x0000D8, "Member 'UFlowNode_LogicalAND::ExecutedInputNames' has a wrong offset!");

// Class Flow.FlowNode_LogicalOR
// 0x0010 (0x00E8 - 0x00D8)
class UFlowNode_LogicalOR final : public UFlowNode
{
public:
	bool                                          bEnabled;                                          // 0x00D8(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExecutionLimit;                                    // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExecutionCount;                                    // 0x00E0(0x0004)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_LogicalOR">();
	}
	static class UFlowNode_LogicalOR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_LogicalOR>();
	}
};
static_assert(alignof(UFlowNode_LogicalOR) == 0x000008, "Wrong alignment on UFlowNode_LogicalOR");
static_assert(sizeof(UFlowNode_LogicalOR) == 0x0000E8, "Wrong size on UFlowNode_LogicalOR");
static_assert(offsetof(UFlowNode_LogicalOR, bEnabled) == 0x0000D8, "Member 'UFlowNode_LogicalOR::bEnabled' has a wrong offset!");
static_assert(offsetof(UFlowNode_LogicalOR, ExecutionLimit) == 0x0000DC, "Member 'UFlowNode_LogicalOR::ExecutionLimit' has a wrong offset!");
static_assert(offsetof(UFlowNode_LogicalOR, ExecutionCount) == 0x0000E0, "Member 'UFlowNode_LogicalOR::ExecutionCount' has a wrong offset!");

// Class Flow.FlowNode_Counter
// 0x0008 (0x00E0 - 0x00D8)
class UFlowNode_Counter final : public UFlowNode
{
public:
	int32                                         Goal;                                              // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSum;                                        // 0x00DC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Counter">();
	}
	static class UFlowNode_Counter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Counter>();
	}
};
static_assert(alignof(UFlowNode_Counter) == 0x000008, "Wrong alignment on UFlowNode_Counter");
static_assert(sizeof(UFlowNode_Counter) == 0x0000E0, "Wrong size on UFlowNode_Counter");
static_assert(offsetof(UFlowNode_Counter, Goal) == 0x0000D8, "Member 'UFlowNode_Counter::Goal' has a wrong offset!");
static_assert(offsetof(UFlowNode_Counter, CurrentSum) == 0x0000DC, "Member 'UFlowNode_Counter::CurrentSum' has a wrong offset!");

// Class Flow.FlowNode_CustomEventBase
// 0x0008 (0x00E0 - 0x00D8)
class UFlowNode_CustomEventBase : public UFlowNode
{
public:
	class FName                                   EventName;                                         // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_CustomEventBase">();
	}
	static class UFlowNode_CustomEventBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_CustomEventBase>();
	}
};
static_assert(alignof(UFlowNode_CustomEventBase) == 0x000008, "Wrong alignment on UFlowNode_CustomEventBase");
static_assert(sizeof(UFlowNode_CustomEventBase) == 0x0000E0, "Wrong size on UFlowNode_CustomEventBase");
static_assert(offsetof(UFlowNode_CustomEventBase, EventName) == 0x0000D8, "Member 'UFlowNode_CustomEventBase::EventName' has a wrong offset!");

// Class Flow.FlowNode_CustomInput
// 0x0000 (0x00E0 - 0x00E0)
class UFlowNode_CustomInput final : public UFlowNode_CustomEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_CustomInput">();
	}
	static class UFlowNode_CustomInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_CustomInput>();
	}
};
static_assert(alignof(UFlowNode_CustomInput) == 0x000008, "Wrong alignment on UFlowNode_CustomInput");
static_assert(sizeof(UFlowNode_CustomInput) == 0x0000E0, "Wrong size on UFlowNode_CustomInput");

// Class Flow.FlowNode_CustomOutput
// 0x0000 (0x00E0 - 0x00E0)
class UFlowNode_CustomOutput final : public UFlowNode_CustomEventBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_CustomOutput">();
	}
	static class UFlowNode_CustomOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_CustomOutput>();
	}
};
static_assert(alignof(UFlowNode_CustomOutput) == 0x000008, "Wrong alignment on UFlowNode_CustomOutput");
static_assert(sizeof(UFlowNode_CustomOutput) == 0x0000E0, "Wrong size on UFlowNode_CustomOutput");

// Class Flow.FlowNode_ExecutionMultiGate
// 0x0020 (0x00F8 - 0x00D8)
class UFlowNode_ExecutionMultiGate final : public UFlowNode
{
public:
	bool                                          bRandom;                                           // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartIndex;                                        // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextOutput;                                        // 0x00E0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  Completed;                                         // 0x00E8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ExecutionMultiGate">();
	}
	static class UFlowNode_ExecutionMultiGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ExecutionMultiGate>();
	}
};
static_assert(alignof(UFlowNode_ExecutionMultiGate) == 0x000008, "Wrong alignment on UFlowNode_ExecutionMultiGate");
static_assert(sizeof(UFlowNode_ExecutionMultiGate) == 0x0000F8, "Wrong size on UFlowNode_ExecutionMultiGate");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, bRandom) == 0x0000D8, "Member 'UFlowNode_ExecutionMultiGate::bRandom' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, bLoop) == 0x0000D9, "Member 'UFlowNode_ExecutionMultiGate::bLoop' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, StartIndex) == 0x0000DC, "Member 'UFlowNode_ExecutionMultiGate::StartIndex' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, NextOutput) == 0x0000E0, "Member 'UFlowNode_ExecutionMultiGate::NextOutput' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, Completed) == 0x0000E8, "Member 'UFlowNode_ExecutionMultiGate::Completed' has a wrong offset!");

// Class Flow.FlowNode_ExecutionSequence
// 0x0058 (0x0130 - 0x00D8)
class UFlowNode_ExecutionSequence final : public UFlowNode
{
public:
	bool                                          bSavePinExecutionState;                            // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGuid>                            ExecutedConnections;                               // 0x00E0(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ExecutionSequence">();
	}
	static class UFlowNode_ExecutionSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ExecutionSequence>();
	}
};
static_assert(alignof(UFlowNode_ExecutionSequence) == 0x000008, "Wrong alignment on UFlowNode_ExecutionSequence");
static_assert(sizeof(UFlowNode_ExecutionSequence) == 0x000130, "Wrong size on UFlowNode_ExecutionSequence");
static_assert(offsetof(UFlowNode_ExecutionSequence, bSavePinExecutionState) == 0x0000D8, "Member 'UFlowNode_ExecutionSequence::bSavePinExecutionState' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionSequence, ExecutedConnections) == 0x0000E0, "Member 'UFlowNode_ExecutionSequence::ExecutedConnections' has a wrong offset!");

// Class Flow.FlowNode_Finish
// 0x0000 (0x00D8 - 0x00D8)
class UFlowNode_Finish final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Finish">();
	}
	static class UFlowNode_Finish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Finish>();
	}
};
static_assert(alignof(UFlowNode_Finish) == 0x000008, "Wrong alignment on UFlowNode_Finish");
static_assert(sizeof(UFlowNode_Finish) == 0x0000D8, "Wrong size on UFlowNode_Finish");

// Class Flow.FlowNode_Reroute
// 0x0000 (0x00D8 - 0x00D8)
class UFlowNode_Reroute final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Reroute">();
	}
	static class UFlowNode_Reroute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Reroute>();
	}
};
static_assert(alignof(UFlowNode_Reroute) == 0x000008, "Wrong alignment on UFlowNode_Reroute");
static_assert(sizeof(UFlowNode_Reroute) == 0x0000D8, "Wrong size on UFlowNode_Reroute");

// Class Flow.FlowNode_Start
// 0x0000 (0x00D8 - 0x00D8)
class UFlowNode_Start final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Start">();
	}
	static class UFlowNode_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Start>();
	}
};
static_assert(alignof(UFlowNode_Start) == 0x000008, "Wrong alignment on UFlowNode_Start");
static_assert(sizeof(UFlowNode_Start) == 0x0000D8, "Wrong size on UFlowNode_Start");

// Class Flow.FlowNode_SubGraph
// 0x0048 (0x0120 - 0x00D8)
class UFlowNode_SubGraph final : public UFlowNode
{
public:
	TSoftObjectPtr<class UFlowAsset>              Asset;                                             // 0x00D8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanInstanceIdenticalAsset;                        // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedAssetInstanceName;                            // 0x0110(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_SubGraph">();
	}
	static class UFlowNode_SubGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_SubGraph>();
	}
};
static_assert(alignof(UFlowNode_SubGraph) == 0x000008, "Wrong alignment on UFlowNode_SubGraph");
static_assert(sizeof(UFlowNode_SubGraph) == 0x000120, "Wrong size on UFlowNode_SubGraph");
static_assert(offsetof(UFlowNode_SubGraph, Asset) == 0x0000D8, "Member 'UFlowNode_SubGraph::Asset' has a wrong offset!");
static_assert(offsetof(UFlowNode_SubGraph, bCanInstanceIdenticalAsset) == 0x000108, "Member 'UFlowNode_SubGraph::bCanInstanceIdenticalAsset' has a wrong offset!");
static_assert(offsetof(UFlowNode_SubGraph, SavedAssetInstanceName) == 0x000110, "Member 'UFlowNode_SubGraph::SavedAssetInstanceName' has a wrong offset!");

// Class Flow.FlowNode_Timer
// 0x0028 (0x0100 - 0x00D8)
class UFlowNode_Timer final : public UFlowNode
{
public:
	float                                         CompletionTime;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepTime;                                          // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SumOfSteps;                                        // 0x00F0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RemainingCompletionTime;                           // 0x00F4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RemainingStepTime;                                 // 0x00F8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompletion();
	void OnStep();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Timer">();
	}
	static class UFlowNode_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Timer>();
	}
};
static_assert(alignof(UFlowNode_Timer) == 0x000008, "Wrong alignment on UFlowNode_Timer");
static_assert(sizeof(UFlowNode_Timer) == 0x000100, "Wrong size on UFlowNode_Timer");
static_assert(offsetof(UFlowNode_Timer, CompletionTime) == 0x0000D8, "Member 'UFlowNode_Timer::CompletionTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, StepTime) == 0x0000DC, "Member 'UFlowNode_Timer::StepTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, SumOfSteps) == 0x0000F0, "Member 'UFlowNode_Timer::SumOfSteps' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, RemainingCompletionTime) == 0x0000F4, "Member 'UFlowNode_Timer::RemainingCompletionTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, RemainingStepTime) == 0x0000F8, "Member 'UFlowNode_Timer::RemainingStepTime' has a wrong offset!");

// Class Flow.FlowNode_Checkpoint
// 0x0000 (0x00D8 - 0x00D8)
class UFlowNode_Checkpoint final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Checkpoint">();
	}
	static class UFlowNode_Checkpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Checkpoint>();
	}
};
static_assert(alignof(UFlowNode_Checkpoint) == 0x000008, "Wrong alignment on UFlowNode_Checkpoint");
static_assert(sizeof(UFlowNode_Checkpoint) == 0x0000D8, "Wrong size on UFlowNode_Checkpoint");

// Class Flow.FlowNode_Log
// 0x0020 (0x00F8 - 0x00D8)
class UFlowNode_Log final : public UFlowNode
{
public:
	class FString                                 Message;                                           // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFlowLogVerbosity                             Verbosity;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPrintToScreen;                                    // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 TextColor;                                         // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Log">();
	}
	static class UFlowNode_Log* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Log>();
	}
};
static_assert(alignof(UFlowNode_Log) == 0x000008, "Wrong alignment on UFlowNode_Log");
static_assert(sizeof(UFlowNode_Log) == 0x0000F8, "Wrong size on UFlowNode_Log");
static_assert(offsetof(UFlowNode_Log, Message) == 0x0000D8, "Member 'UFlowNode_Log::Message' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, Verbosity) == 0x0000E8, "Member 'UFlowNode_Log::Verbosity' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, bPrintToScreen) == 0x0000E9, "Member 'UFlowNode_Log::bPrintToScreen' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, Duration) == 0x0000EC, "Member 'UFlowNode_Log::Duration' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, TextColor) == 0x0000F0, "Member 'UFlowNode_Log::TextColor' has a wrong offset!");

// Class Flow.FlowNode_CallOwnerFunction
// 0x0018 (0x00F0 - 0x00D8)
class UFlowNode_CallOwnerFunction final : public UFlowNode
{
public:
	struct FFlowOwnerFunctionRef                  FunctionRef;                                       // 0x00D8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UFlowOwnerFunctionParams*               Params_0;                                          // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_CallOwnerFunction">();
	}
	static class UFlowNode_CallOwnerFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_CallOwnerFunction>();
	}
};
static_assert(alignof(UFlowNode_CallOwnerFunction) == 0x000008, "Wrong alignment on UFlowNode_CallOwnerFunction");
static_assert(sizeof(UFlowNode_CallOwnerFunction) == 0x0000F0, "Wrong size on UFlowNode_CallOwnerFunction");
static_assert(offsetof(UFlowNode_CallOwnerFunction, FunctionRef) == 0x0000D8, "Member 'UFlowNode_CallOwnerFunction::FunctionRef' has a wrong offset!");
static_assert(offsetof(UFlowNode_CallOwnerFunction, Params_0) == 0x0000E8, "Member 'UFlowNode_CallOwnerFunction::Params_0' has a wrong offset!");

// Class Flow.FlowNode_ComponentObserver
// 0x0080 (0x0158 - 0x00D8)
class UFlowNode_ComponentObserver : public UFlowNode
{
public:
	struct FGameplayTagContainer                  IdentityTags;                                      // 0x00D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	EFlowTagContainerMatchType                    IdentityMatchType;                                 // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SuccessLimit;                                      // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SuccessCount;                                      // 0x0100(0x0004)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x54];                                     // 0x0104(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnComponentRegistered(class UFlowComponent* Component);
	void OnComponentTagAdded(class UFlowComponent* Component, const struct FGameplayTagContainer& AddedTags);
	void OnComponentTagRemoved(class UFlowComponent* Component, const struct FGameplayTagContainer& RemovedTags);
	void OnComponentUnregistered(class UFlowComponent* Component);
	void OnEventReceived();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ComponentObserver">();
	}
	static class UFlowNode_ComponentObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ComponentObserver>();
	}
};
static_assert(alignof(UFlowNode_ComponentObserver) == 0x000008, "Wrong alignment on UFlowNode_ComponentObserver");
static_assert(sizeof(UFlowNode_ComponentObserver) == 0x000158, "Wrong size on UFlowNode_ComponentObserver");
static_assert(offsetof(UFlowNode_ComponentObserver, IdentityTags) == 0x0000D8, "Member 'UFlowNode_ComponentObserver::IdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_ComponentObserver, IdentityMatchType) == 0x0000F8, "Member 'UFlowNode_ComponentObserver::IdentityMatchType' has a wrong offset!");
static_assert(offsetof(UFlowNode_ComponentObserver, SuccessLimit) == 0x0000FC, "Member 'UFlowNode_ComponentObserver::SuccessLimit' has a wrong offset!");
static_assert(offsetof(UFlowNode_ComponentObserver, SuccessCount) == 0x000100, "Member 'UFlowNode_ComponentObserver::SuccessCount' has a wrong offset!");

// Class Flow.FlowNode_NotifyActor
// 0x0050 (0x0128 - 0x00D8)
class UFlowNode_NotifyActor final : public UFlowNode
{
public:
	struct FGameplayTagContainer                  IdentityTags;                                      // 0x00D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	EGameplayContainerMatchType                   MatchType;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExactMatch;                                       // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  NotifyTags;                                        // 0x0100(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	EFlowNetMode                                  NetMode;                                           // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_NotifyActor">();
	}
	static class UFlowNode_NotifyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_NotifyActor>();
	}
};
static_assert(alignof(UFlowNode_NotifyActor) == 0x000008, "Wrong alignment on UFlowNode_NotifyActor");
static_assert(sizeof(UFlowNode_NotifyActor) == 0x000128, "Wrong size on UFlowNode_NotifyActor");
static_assert(offsetof(UFlowNode_NotifyActor, IdentityTags) == 0x0000D8, "Member 'UFlowNode_NotifyActor::IdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, MatchType) == 0x0000F8, "Member 'UFlowNode_NotifyActor::MatchType' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, bExactMatch) == 0x0000F9, "Member 'UFlowNode_NotifyActor::bExactMatch' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, NotifyTags) == 0x000100, "Member 'UFlowNode_NotifyActor::NotifyTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, NetMode) == 0x000120, "Member 'UFlowNode_NotifyActor::NetMode' has a wrong offset!");

// Class Flow.FlowNode_OnActorRegistered
// 0x0000 (0x0158 - 0x0158)
class UFlowNode_OnActorRegistered final : public UFlowNode_ComponentObserver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnActorRegistered">();
	}
	static class UFlowNode_OnActorRegistered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnActorRegistered>();
	}
};
static_assert(alignof(UFlowNode_OnActorRegistered) == 0x000008, "Wrong alignment on UFlowNode_OnActorRegistered");
static_assert(sizeof(UFlowNode_OnActorRegistered) == 0x000158, "Wrong size on UFlowNode_OnActorRegistered");

// Class Flow.FlowNode_OnActorUnregistered
// 0x0000 (0x0158 - 0x0158)
class UFlowNode_OnActorUnregistered final : public UFlowNode_ComponentObserver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnActorUnregistered">();
	}
	static class UFlowNode_OnActorUnregistered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnActorUnregistered>();
	}
};
static_assert(alignof(UFlowNode_OnActorUnregistered) == 0x000008, "Wrong alignment on UFlowNode_OnActorUnregistered");
static_assert(sizeof(UFlowNode_OnActorUnregistered) == 0x000158, "Wrong size on UFlowNode_OnActorUnregistered");

// Class Flow.FlowNode_OnNotifyFromActor
// 0x0028 (0x0180 - 0x0158)
class UFlowNode_OnNotifyFromActor final : public UFlowNode_ComponentObserver
{
public:
	struct FGameplayTagContainer                  NotifyTags;                                        // 0x0158(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bRetroactive;                                      // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnNotifyFromActor">();
	}
	static class UFlowNode_OnNotifyFromActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnNotifyFromActor>();
	}
};
static_assert(alignof(UFlowNode_OnNotifyFromActor) == 0x000008, "Wrong alignment on UFlowNode_OnNotifyFromActor");
static_assert(sizeof(UFlowNode_OnNotifyFromActor) == 0x000180, "Wrong size on UFlowNode_OnNotifyFromActor");
static_assert(offsetof(UFlowNode_OnNotifyFromActor, NotifyTags) == 0x000158, "Member 'UFlowNode_OnNotifyFromActor::NotifyTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_OnNotifyFromActor, bRetroactive) == 0x000178, "Member 'UFlowNode_OnNotifyFromActor::bRetroactive' has a wrong offset!");

// Class Flow.FlowNode_PlayLevelSequence
// 0x0160 (0x0238 - 0x00D8)
class UFlowNode_PlayLevelSequence final : public UFlowNode
{
public:
	TSoftObjectPtr<class ULevelSequence>          Sequence;                                          // 0x00D8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x0108(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPlayReverse;                                      // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLevelSequenceCameraSettings           CameraSettings;                                    // 0x0129(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseGraphOwnerAsTransformOrigin;                   // 0x012B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicates;                                       // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysRelevant;                                   // 0x012D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyOwnerTimeDilation;                           // 0x012E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12F[0x1];                                      // 0x012F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         LoadedSequence;                                    // 0x0130(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlowLevelSequencePlayer*               SequencePlayer;                                    // 0x0138(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x4];                                      // 0x0140(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0144(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x0148(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeDilation;                                      // 0x014C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0xE8];                                     // 0x0150(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlaybackFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_PlayLevelSequence">();
	}
	static class UFlowNode_PlayLevelSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_PlayLevelSequence>();
	}
};
static_assert(alignof(UFlowNode_PlayLevelSequence) == 0x000008, "Wrong alignment on UFlowNode_PlayLevelSequence");
static_assert(sizeof(UFlowNode_PlayLevelSequence) == 0x000238, "Wrong size on UFlowNode_PlayLevelSequence");
static_assert(offsetof(UFlowNode_PlayLevelSequence, Sequence) == 0x0000D8, "Member 'UFlowNode_PlayLevelSequence::Sequence' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, PlaybackSettings) == 0x000108, "Member 'UFlowNode_PlayLevelSequence::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, bPlayReverse) == 0x000128, "Member 'UFlowNode_PlayLevelSequence::bPlayReverse' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, CameraSettings) == 0x000129, "Member 'UFlowNode_PlayLevelSequence::CameraSettings' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, bUseGraphOwnerAsTransformOrigin) == 0x00012B, "Member 'UFlowNode_PlayLevelSequence::bUseGraphOwnerAsTransformOrigin' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, bReplicates) == 0x00012C, "Member 'UFlowNode_PlayLevelSequence::bReplicates' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, bAlwaysRelevant) == 0x00012D, "Member 'UFlowNode_PlayLevelSequence::bAlwaysRelevant' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, bApplyOwnerTimeDilation) == 0x00012E, "Member 'UFlowNode_PlayLevelSequence::bApplyOwnerTimeDilation' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, LoadedSequence) == 0x000130, "Member 'UFlowNode_PlayLevelSequence::LoadedSequence' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, SequencePlayer) == 0x000138, "Member 'UFlowNode_PlayLevelSequence::SequencePlayer' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, StartTime) == 0x000144, "Member 'UFlowNode_PlayLevelSequence::StartTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, ElapsedTime) == 0x000148, "Member 'UFlowNode_PlayLevelSequence::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, TimeDilation) == 0x00014C, "Member 'UFlowNode_PlayLevelSequence::TimeDilation' has a wrong offset!");

}

